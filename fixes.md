# fixes
- check somehow whether both mutexes are free before taking either - this just makes deadlocks impossible
- implement a system where (probably in the thinking logic) you are on a schedule based on your id and the eating time. You should only stop thinking when you are roughly in the expected time to start eating. An offset needs to be taken into account for this, as delays will occur. This offset can be a simple int that gets generated by the eating function and just gets applied to the next expected eating time.


# already implemented
- start off odd and even philosophers with different actions
- have odd philosophers take their forks in a different order, reducing deadlock chance
- own sleep function to reduce usual usleep imprecisions




check total number of philos. if its uneven, we need the philo 1 to be the first one to eat, if not, philo 0 should be
- otherwise, 0 and the last will steal each others forks.
- save this info, its good for scheduling

in the loop, the save the amount of ms offset and the exact expected eating time.
- these both get passed by reference into thinking function (finally, its useful!)
- here, the values get updated. basically, normally expected value in a perfect scenario + offset to account for random computer delays
in eat, take in those two values as well (maybe too many parameters or whatever, just save it in the philo struct i say)
- calculate a reasonable range to start eating in - should most definitely be smaller than the smallest of the input parameters (maybe half of the smallest?)
- wait 10 ms until you reach that

it doesnt really work - if we have an uneven number of philos, we run into problems. better than before though!
if we have 5 philos, they should eat in the following order: 1 + 4 - 2 + 5 - 3 + 1 - 4 + 2 - 5 + 3 - 1 + 4, loop that
- we gotta code that in.... somehow.... because as it stands we only survive for even numbers of philos